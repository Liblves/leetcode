<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        function partition(unordArr,left,right) {
            let targetIndex = left-1
            let targetNum = unordArr[targetIndex]
            while(left < right) {
                for(let i = right;i > left;i--) {
                    if(unordArr[right] < targetNum) {
                        unordArr[left-1]= unordArr[right]//左边的空位置始终在赋值时的left左边一个
                        right--//当赋值之后需要将right向左移一个，因为下次进入该循环时上次结束循环时的位置是left赋值过来的值，虽然不受影响，减少代码执行时间
                        break;
                    }
                    right--//将下一次的right提前移动即right--，会造成实际还没监测该位置上的值，就使得left<right退出循环
                }//while循环只有不满足条件立即退出
                for(let j = left;j < right;j++){
                    if(unordArr[left] > targetNum){//此时的targetindex上的值已经不是目标值了,所以用变量存起来
                        unordArr[right+1] = unordArr[left]//右边的空位置始终在赋值时的right右边一个
                        left++
                        break;
                    }
                    left++
                }
            }
            unordArr[right] = targetNum//把这个值归位
            console.log(unordArr);
            return right
        } 
        // function quicSort(unordArr,left,right){
        //     if(left < right) {
        //        let min = partition(unordArr,left,right)
        //        quicSort(unordArr,left,min-1)
        //        quicSort(unordArr,min+1,right) 
        //     }
        //     console.log(unordArr);
        // }
        partition([5,7,4,6,3,1,9],1,6)
    </script>
</body>
</html>