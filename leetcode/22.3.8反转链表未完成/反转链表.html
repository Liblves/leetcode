<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 首先从逻辑结构上说，两者都是数据结构的一种，但存在区别，数组是申请的一块连续的内存空间，
    并且是在编译阶段就要确定空间大小的，同时在运行阶段是不允许改变的，所以它不能够随着需要
    的改变而增加或减少空间大小，所以当数据量大的时候，有可能超出了已申请好的数组上限，产生
    数据越界，或者是数据量很小，对于没有使用的数组空间，造成内存浪费。链表则是动态申请的内
    存空间，并不像数组一样需要事先申请好大小，链表是现用现申请就OK，根据需求动态的申请或删
    除内存空间，对于的是增加或删除数据，所以比数组要灵活。再从物理存储即内存分配上分析，数
    组是连续的内存，对于访问数据，可以通过下标直接读取，时间复杂度为O(1)，而添加删除数据就
    比较麻烦，需要移动操作数所在位置后的所有数据，时间复杂度为O（N）。链表是物理上非连续的
    内存空间，对于访问数据，需要从头便利整个链表直到找到要访问的数据，没有数组有效，但是在
    添加和删除数据方面，只需要知道操作位置的指针，很方便可以实现增删，教数组比较灵活有效率。
    所以综合以上，对于快速访问数据，不经常有添加删除操作的时候选择数组实现，而对于经常添加
    删除数据，对于访问没有很高要求的时候选择链表。 -->
    <script>
        // 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
        // 输入：head = [1,2,3,4,5]
        // 输出：[5,4,3,2,1]
        // 输入：head = []
        // 输出：[]
        /**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
        const reversal = function(head) {
            let res = []
            for (let i = head.length-1;i>=0;i--){
                res[res.length] = head[i]

            }
            
            return (res)
        }
        console.log(reversal([1,2,3,4,5]));
    </script>
</body>
</html>